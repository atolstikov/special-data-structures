\section{Битовое представление множества}
Во многих случаях оказывается очень удобным представить множество с помощь битовой маски.
Такое представление позволяет выполнять логические опирации в векторном стиле, т.к. машинное слово,
как правило, содержит 32 или 64 бита и позволяет за одну инструкцию процесса выполнить попарных битовые операции ``И'', ``ИЛИ'', ``логическое НЕ'', ``исключающее ИЛИ''. Кроме этого в некоторых случаях удобным может оказаться и использование сдвига множества на некоторое число.

Далее рассмотри несколько примеров, когда битовое представление может быть очень удобным и эффективным.

\subsection{Задача о коммивояжере}

Задача о коммивояжере (англ. Travelling salesman problem, TSP)~-- задача, в которой коммивояжер должен посетить $N$ городов, побывав в каждом из них ровно по одному разу и завершив путешествие в том городе, с которого он начал. В какой последовательности ему нужно обходить города, чтобы общая длина его пути была наименьшей?

Можно решить задачу перебором всевозможных перестановок. Для этого нужно сгенерировать все $N!$ всевозможных перестановок вершин исходного графа, подсчитать для каждой перестановки длину маршрута и выбрать минимальный из них. Но тогда задача оказывается неосуществимой даже для достаточно небольших $N$. Сложность алгоритма $O(N! \times N)$.

Задача о коммивояжере представляет собой поиск кратчайшего гамильтонова цикла в графе. Зафиксируем начальную вершину $s$ и будем искать гамильтонов цикл наименьшей стоимости — путь от $s$ до $s$, проходящий по всем вершинам (кроме первоначальной) один раз. Т.к. искомый цикл проходит через каждую вершину, то выбор $s$ не имеет значения. Поэтому будем считать $s=0$.

Подмножества вершин будем кодировать битовыми векторами, обозначим $mask_i$ значение $i$-ого бита в векторе $mask$.

Обозначим $d[i][mask]$ как наименьшую стоимость пути из вершины $i$ в вершину $0$, проходящую (не считая вершины $i$) единожды по всем тем и только тем вершинам $j$, для которых $mask_{j}=1$ (т.е. $d[i][mask]$ уже найденный оптимальный путь от $i$-ой вершины до $0$-ой, проходящий через те вершины, где $mask_{j}=1$. Если $mask_{j}=0$,то эти вершины еще не посещены).

Алгоритм поиска цикла будет выглядеть следующим образом:
\begin{itemize}
    \item Начальное состояние — когда находимся в $0$-й вершине, ни одна вершина не посещена, а пройденный путь равен 0 (т.е. $i=0$ и $mask=0$).
    \item Для остальных состояний ($i \ne 0$ или $mask \ne 0$) перебираем все возможные переходы в $i$-ую вершину из любой посещенной ранее и выбираем минимальный результат.
    \item Если возможные переходы отсутствуют, решения для данной подзадачи не существует (обозначим ответ для такой подзадачи как $\infty$).
\end{itemize}

Стоимостью минимального гамильтонова цикла в исходном графе будет значение $d[0][2^{n}-1]$~-- стоимость пути из $0$-й вершины в $0$-ю, при необходимости посетить все вершины. Данное решение требует $O(2^{n} \times n)$ памяти и $O(2^{n} \times n^{2})$ времени.

Для того, чтобы восстановить сам путь, воспользуемся соотношением $d[i][mask]=w(i,j)+d[j][mask-2^{j}]$, которое выполняется для всех ребер, входящих в минимальный цикл. Начнем с состояния $i=0$, $mask=2^{n}-1$, найдем вершину $j$, для которой выполняется указанное соотношение, добавим $j$ в ответ, пересчитаем текущее состояние как $i=j$, $mask=mask-2^{j}$. Процесс заканчивается в состоянии $i=0$, $mask=0$.

\subsection{Класс bitset}
Тип объекта, который хранит последовательность, состоящую из фиксированного числа битов, предоставляющих компактный способ хранения флагов для набора элементов или условий. Класс bitset поддерживает операции над объектами типа bitset, которые содержат коллекцию битов и обеспечивают доступ в константном времени к каждому биту.

\subsubsection{Транзитивное замыкание}
Алгоритм Флойда-Уоршала можно значительно ускорить, если строки обрабатывать в векторном стиле.

\subsubsection{Решение систем линейных уравнение по модулю 2}
Алгоритм Гаусса можно значительно ускорить, если строки обрабатывать в векторном стиле.

Аналогичный трюк можно провернуть, если нужно найти ранг двоичной матрицы.

\subsubsection{Задача о рюкзаке}
Если внимательно посмотреть на решение задачи о рюкзаке, то получается, что новая строка матрицы
возможных весов (которые можно набрать, используя какие-то из $k$ первых предметов) является
результатом ``логического ИЛИ'' предыдущей строки и ее же, но сдвинутой на $w_k$ единиц вправо.
