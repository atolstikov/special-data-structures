\section{Оценка трудоемкости операций со структурами данных}
\subsection{Абстрактная структуда данных}
Абстрактные структуры данных предназначены для удобного хранения и доступа к информации.
Они предоставляют удобный интерфейс для типичных операций с хранимыми объектами, скрывая детали реализации от пользователя.
Конечно, это весьма удобно и позволяет добиться большей модульности программы.
Абстрактные структуры данных иногда делят на две части:
интерфейс, набор операций над объектами, который называют АТД (абстрактный тип данных) и реализацию.

Ниже, где возможно, собственно АТД будут отделены от их реализации:

\addcontentsline{toc}{subsubsection}{Статический массив}\subsubsection*{Статический массив}
При создании статического массива указывается его размер и память сразу выделяется под все данные.

Интерфейс:
\begin{itemize}
    \item Получить элемент с номером $i$
    \item Записать элемент с номером $i$
\end{itemize}

\addcontentsline{toc}{subsubsection}{Динамический массив}\subsubsection*{Динамический массив}
При создании динамического массива указывается его начальный размер, это память сразу выделяется под данные.

Интерфейс:
\begin{itemize}
    \item Добавить элемент в конец массива
    \item Удалить элемент в конце массив
    \item Узнать размер массива
    \item Получить элемент с номером $i$
    \item Записать элемент с номером $i$
\end{itemize}

\addcontentsline{toc}{subsubsection}{Список, стек, очередь, дек}\subsubsection*{Список, стек, очередь, дек}

Классические структуры данных, интерфейсы этих структур данных.

Придумать метод релизации интерфейса очереди, имея только возможность создавать сущности с интерфейсом стека.

\subsection{Оценка трудоемкости операций}
Время работы алгоритма на входных данных $X$~--- это число элементарных операций, выполняемых алгоритмом при обработке $X$.

\addcontentsline{toc}{subsubsection}{Трудоемкость в худшем случае}\subsubsection*{Трудоемкость в худшем случае}

Пусть имеется некоторый алгоритм $A$, тогда $T_A(n)$~--- максимальное время работы алгоритма $A$ на входе размера $n$.
$T_A(n)$~--- трудоемкость алгоритма $A$.

Определите трудоемкость (предложите алгоритм):
\begin{itemize}
    \item Подсчета числа делителей числа
    \item Сортировки массива произвольных целых чисел
    \item Сортировки массива возрастов пользователей социальной сети
    \item Поиска элемента в отсортированном массиве
    \item Слияние двух отсортированных массивов
    \item Слияние двух отсортированных массивов, расположенных в последовательной памяти, не используя дополнительной памяти
    \item Поиска $k$ элементов $a_1$, \ldots, $a_k$ ($a_i \le a_{i+1}$) в отсортированном массиве $B$.
\end{itemize}

\addcontentsline{toc}{subsubsection}{Амортизационный анализ}\subsubsection*{Амортизационный анализ}
\textbf{Амортизационный анализ} (англ. amortized analysis)~--- метод подсчета времени,
требуемого для выполнения последовательности операций над структурой данных.
При этом время усредняется по всем выполняемым операциям, и анализируется средняя производительность операций в худшем случае.

Такой анализ чаще всего используется, чтобы показать, что даже если некоторые из операций последовательности являются
дорогостоящими, то при усреднении по всем операциям средняя их стоимость будет небольшой за счёт низкой частоты встречаемости.
Оценка, даваемая амортизационным анализом, не является вероятностной:
это оценка среднего времени выполнения операций для худшего случая.

\textbf{Средняя амортизационная стоимость операций}~--- величина $a$, находящаяся по формуле: $a=\frac{\sum^{n}_{i}{t_i}}{n}$, где $t_1$,$t_2$,
\dots,$t_n$~--- время выполнения операций $1$, $2$, \dots, $n$, совершённых над структурой данных.

Амортизационный анализ использует следующие методы:
\begin{enumerate}
    \item Метод усреднения (метод группового анализа).
    \item Метод потенциалов.
    \item Метод предоплаты (метод бухгалтерского учета).
\end{enumerate}

В методе усреднения амортизационная стоимость операций определяется напрямую по формуле, указанной выше:
суммарная стоимость всех операций алгоритма делится на их количество.

Введём для каждого состояния структуры данных величину $\Phi$~--- потенциал.
Изначально потенциал равен $\Phi_0$, а после выполнения $i$-й операции — $\Phi_i$.
Стоимость $i$-й операции обозначим $a_i=t_i+\Phi_{i}-\Phi_{i-1}$.
Пусть $n$~--- количество операций, $m$ — размер структуры данных.
Тогда средняя амортизационная стоимость операций $a=O(f(n,m))$, если выполнены два условия:
\begin{enumerate}
    \item Для любого $i$: $a_i=O(f(n,m))$.
    \item Для любого $i$: $\Phi_{i}=O(n \cdot f(n,m))$.
\end{enumerate}

Представим, что использование определенного количества времени равносильно использованию определенного количества монет
(плата за выполнение каждой операции).
В методе предоплаты каждому типу операций присваивается своя учётная стоимость.
Эта стоимость может быть больше фактической, в таком случае лишние монеты используются как резерв для выполнения других
операций в будущем, а может быть меньше, тогда гарантируется, что текущего накопленного резерва достаточно для выполнения
операции.
Для доказательства оценки средней амортизационной стоимости $O(f(n,m))$ нужно построить учётные стоимости так,
что для каждой операции она будет составлять $O(f(n,m))$.
Тогда для последовательности из $n$ операций суммарно будет затрачено $n \cdot O(f(n,m))$ монет, следовательно,
средняя амортизационная стоимость операций будет $a=\frac{\sum^{n}_{i}{t_i}}{n}=\frac{n \cdot O(f(n,m))}{n}=O(f(n,m))$.

Определите амортизационную стоимость (предложите алгоритм):
\begin{itemize}
    \item Стек с multipop.
    \item Двоичный счётчик.
    \item КМП алгоритм поиска вхождения шаблона в текст.
    \item Построение всех перестановок.
    \item Рекурсивный обход дерева.
    \item Рекурсивный обход бинарного поискового дерева с выводом ключей $k$ ($x \le k \le y$).
\end{itemize}

\addcontentsline{toc}{subsubsection}{*Стек, очередь, дек с поиском минимального элемента}\subsubsection*{*Стек, очередь, дек с поиском минимального элемента}
Необходимо добавить операцию поиска минимального элемента в классический интерфейс.

\addcontentsline{toc}{subsubsection}{Оценка времени работы на случайных входных данных}\subsubsection*{Оценка времени работы на случайных входных данных}
Среднее время работы~--- усредненное время работы алгоритма по всем входным данным размерности $n$.
Т.е. в среднем случае мы рассматриваем различные входные данные как равновероятные.

Среднее время работы (предложите алгоритм):
\begin{itemize}
    \item Поиск в перестановке.
    \item Поиск в отсортиванном массиве.
    \item Поиск вхождения шаблона (фиксированного) в строке (случайной).
    \item Проверка числа от 1 до $n$ на простоту.
\end{itemize}

\addcontentsline{toc}{subsubsection}{Примеры структур данных с балансировкой времени работы между различными операциями}\subsubsection*{Примеры структур данных с балансировкой времени работы между различными операциями}
\textbf{AddElement} + \textbf{ExtractMin} для алгоритма Дейкстры: в зависимости от плотности графа можно использовать
кучу или тривиальную реализацию на массиве.

\addcontentsline{toc}{subsubsection}{Примеры структур данных с балансировкой между объемом используемой памяти и временем работы}\subsubsection*{Примеры структур данных с балансировкой между объемом используемой памяти и временем работы}
Часто перед нами стоит вопрос, нужно ли стараться сжать данные (упаковать), чтобы потом распаковывать на каждый запрос.
