#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1cm
\rightmargin 1cm
\bottommargin 1cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Part*

\size normal
\lang russian
Амортизированный анализ
\end_layout

\begin_layout Enumerate

\lang russian
Стек с multipop
\end_layout

\begin_layout Enumerate

\lang russian
Двоичный счетчик
\end_layout

\begin_layout Enumerate

\lang russian
Стек с multipop и multipush.
\begin_inset Newline newline
\end_inset

Остается ли справедливой амортизированная оценка стоимости стековых операций,
 равная 
\begin_inset Formula $O(1),$
\end_inset

 если включить в множество стековых операций операцию 
\begin_inset Formula $multipush,$
\end_inset

 помещающая в стек 
\begin_inset Formula $k$
\end_inset

 элементов? 
\end_layout

\begin_layout Enumerate

\lang russian
Счетчик с decrement
\begin_inset Newline newline
\end_inset

Покажите, что если бы в примере с 
\begin_inset Formula $k-$
\end_inset

битовым счетчиком была включена операция 
\begin_inset Formula $decrement,$
\end_inset

то стоимость операций была бы равна 
\begin_inset Formula $\Theta(kn)$
\end_inset

.
\end_layout

\begin_layout Enumerate

\lang russian
Предположим, что над структурой данных выполняется 
\begin_inset Formula $n$
\end_inset

 операций.
 Стоимость 
\begin_inset Formula $i-$
\end_inset

ой по порядку операции равна 
\begin_inset Formula $i$
\end_inset

, если 
\begin_inset Formula $i$
\end_inset

 - это точная степень двойки, и 1 - иначе.
 Определить с помощью группового анализа, метода предоплаты и метода потенциалов
 амортизированную стоимость операции.
\end_layout

\begin_layout Enumerate

\lang russian
Рекурсивный обход дерева
\end_layout

\begin_layout Enumerate

\lang russian
Стек с копированием.
\begin_inset Newline newline
\end_inset

Предположим, что над стеком выполняется последовательность операций.
 Размер стека при этом никогда не превышает 
\begin_inset Formula $k$
\end_inset

.
 После каждых 
\begin_inset Formula $k$
\end_inset

 операций производится резервное копирование стека.
 Присвоив различным стековым операциям соответствующие стоимости, покажите,
 что стоимость 
\begin_inset Formula $n$
\end_inset

 стековых операций, включая копирование стека, равна 
\begin_inset Formula $O(n).$
\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
Счетчик с reset.
\begin_inset Newline newline
\end_inset

Предположим, что нам нужно иметь возможность не только увеличивать показания
 счетчика, но и сбрасывать его.
 Считая, что время проверки или модификации одного бита составляют 
\begin_inset Formula $\Theta(1),$
\end_inset

 покажите, как осуществить реализацию счетчика в виде массива битов, чтобы
 выполнение произвольной последовательности из 
\begin_inset Formula $n$
\end_inset

 операций 
\begin_inset Formula $Increment$
\end_inset

 и 
\begin_inset Formula $Reset$
\end_inset

 над изначально обнуленным счетчиком потребовало бы время 
\begin_inset Formula $O(n).$
\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
Ч
\color black
ему равна полная стоимость выполнения 
\begin_inset Formula $n$
\end_inset

 стековых операций 
\begin_inset Formula $push,\,pop,\,multipop$
\end_inset

, если предположить, что в начале стек содержит 
\begin_inset Formula $k$
\end_inset

 объектов, а в конце 
\begin_inset Formula $m.$
\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
Очередь с минимумом.
 Найти амортизированную стоимость операций.
\end_layout

\begin_layout Enumerate

\lang russian
Дек с минимумом на стеках.
 Найти амортизированную стоимость операций.
\end_layout

\begin_layout Part*

\size normal
\lang russian
Деревья отрезков
\end_layout

\begin_layout Enumerate

\lang russian
Найти минимум на отрезке от 
\begin_inset Formula $l$
\end_inset

 до 
\begin_inset Formula $r$
\end_inset

, а так же число элементов, равных этому значению.
\end_layout

\begin_layout Enumerate

\lang russian
Найти значение суммы 
\begin_inset Formula $a_{l}$
\end_inset

 − 
\begin_inset Formula $a_{l+1}$
\end_inset

 + 
\begin_inset Formula $a_{l+2}$
\end_inset

 − 
\begin_inset Formula $a_{l+3}$
\end_inset

 + ...
 
\begin_inset Formula $\pm$
\end_inset

 
\begin_inset Formula $a_{r-1}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\lang russian
Найти значение суммы 
\begin_inset Formula $a_{l}$
\end_inset

 + 
\begin_inset Formula $2a_{l+1}$
\end_inset

 + 
\begin_inset Formula $3a_{l+2}$
\end_inset

 + ...
 + 
\begin_inset Formula $(r-l)a_{r-1}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\lang russian
Подсчёт количества нулей, поиск 
\begin_inset Formula $k$
\end_inset

-го нуля.
\end_layout

\begin_layout Enumerate

\lang russian
Посчитать количество инверсий в перестановке.
\end_layout

\begin_layout Enumerate

\lang russian
Есть массив 
\begin_inset Formula $a$
\end_inset

 из 
\begin_inset Formula $n$
\end_inset

 целых чисел и две операции: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
присвоить значение: 
\begin_inset Formula $a_{i}=x$
\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
найти минимальное 
\begin_inset Formula $i$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
для которого 
\begin_inset Formula $a_{i}\geq k$
\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
для которого 
\begin_inset Formula $a_{i}\geq k$
\end_inset

 на отрезке от 
\begin_inset Formula $l$
\end_inset

 до 
\begin_inset Formula $r$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\lang russian
Покраска забора — запросы в порядке следования 
\begin_inset Formula $[l_{i}\ldots r_{i}]$
\end_inset

 покрасить в цвет 
\begin_inset Formula $c_{i}$
\end_inset

 — найти сколько какого цвета в итоге.
\end_layout

\begin_layout Enumerate

\lang russian
Покраска забора 2 — красит несколько ребят, и некоторые из них только через
 одну, а запросы такие же — просто понять, что нам нужно два дерева отрезков
 
\end_layout

\begin_layout Enumerate

\lang russian
Дано 
\begin_inset Formula $n$
\end_inset

 целых чисел 
\begin_inset Formula $a_{1},\,a_{2},\ldots,a_{n}$
\end_inset

 и 
\begin_inset Formula $q$
\end_inset

 запросов.
 Запрос — числа 
\begin_inset Formula $l$
\end_inset

 и 
\begin_inset Formula $k$
\end_inset

.
 Ответ на запрос — минимальное число 
\begin_inset Formula $r$
\end_inset

, такое что 
\begin_inset Formula $a[l\ldots r]$
\end_inset

 содержит 
\begin_inset Formula $k$
\end_inset

 различных чисел.
 оффлайн обработка.
\end_layout

\begin_layout Enumerate

\lang russian
Есть массив 
\begin_inset Formula $a$
\end_inset

 из 
\begin_inset Formula $n$
\end_inset

 булеанов.
 Нужно обрабатывать запросы за 
\begin_inset Formula $O(logn)$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
присвоить значение 
\begin_inset Formula $x$
\end_inset

 всем элементам отрезка, найти ближайшую к 
\begin_inset Formula $i$
\end_inset

 единицу 
\end_layout

\begin_layout Enumerate

\lang russian
изменить значение всех элементов отрезка на противоположное, найти число
 единиц на отрезке 
\end_layout

\begin_layout Enumerate

\lang russian
присвоить значение 
\begin_inset Formula $x$
\end_inset

 всем элементам отрезка, 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
выполнить for (i = l ..
 r - 1) : a[i] = a[i] and a[i - 1], 
\end_layout

\begin_layout Enumerate

\lang russian
выполнить for (i = l ..
 r - 1) : a[i] = a[i] or a[i - 1], 
\end_layout

\begin_layout Enumerate

\lang russian
найти число единиц на отрезке
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
присвоить значение 
\begin_inset Formula $x$
\end_inset

 всем элементам отрезка, найти число непрерывных отрезков из единиц
\end_layout

\begin_layout Enumerate

\lang russian
присвоить значение 
\begin_inset Formula $x$
\end_inset

 всем элементам отрезка, найти самый длинный непрерывный отрезок из единиц
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
Сумма квадратов: мы хотим вычислить сумму квадратов на отрезке с возможностью
 увеличения на отрезке и присваивания на отрезке.
\end_layout

\begin_layout Enumerate

\lang russian
Дано 
\begin_inset Formula $n$
\end_inset

 целых чисел 
\begin_inset Formula $a_{1}$
\end_inset

, 
\begin_inset Formula $a_{2}$
\end_inset

,
\begin_inset Formula $\ldots a_{n}$
\end_inset

 и 
\begin_inset Formula $q$
\end_inset

 запросов.
 Запрос — числа 
\begin_inset Formula $l$
\end_inset

 и 
\begin_inset Formula $k$
\end_inset

.
 Ответ на запрос — минимальное число 
\begin_inset Formula $r$
\end_inset

, такое что 
\begin_inset Formula $a[l\ldots r]$
\end_inset

 содержит 
\begin_inset Formula $k$
\end_inset

 различных чисел.
 оффлайн обработка + онлайн (можно просто хранить все возможные деревья,
 если памяти не жалко) 
\end_layout

\begin_layout Enumerate

\lang russian
Дан массив цифр от 
\begin_inset Formula $0$
\end_inset

 до 
\begin_inset Formula $9$
\end_inset

.
 Необходимо обрабатывать запросы «увеличить цифру на 
\begin_inset Formula $1$
\end_inset

» на отрезке (при этом 
\begin_inset Formula $9$
\end_inset

 переходит в 
\begin_inset Formula $0$
\end_inset

), а также запросы на сумму чисел на отрезке.
\end_layout

\begin_layout Enumerate

\lang russian
Дан отсортированный массив 
\begin_inset Formula $a$
\end_inset

 длины 
\begin_inset Formula $n$
\end_inset

.
 Необходимо ответить на 
\begin_inset Formula $q$
\end_inset

запросов, каждый из которых бывает двух типов:
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
сделать 
\begin_inset Formula $a_{i}=\min(a_{i},x)$
\end_inset

 для всех 
\begin_inset Formula $i\leq r$
\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
Найти сумму на отрезке от 
\begin_inset Formula $l$
\end_inset

 до 
\begin_inset Formula $r$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
В языке племени Умба количество слогов определяется не количеством гласных
 букв в слове, а количеством подряд идущих одинаковых символов.
 Например, в словах 
\begin_inset Formula $"а"$
\end_inset

, 
\begin_inset Formula $"aaaa"$
\end_inset

, 
\begin_inset Formula $"aaba"$
\end_inset

 и 
\begin_inset Formula $"aaaabbaabbcee"$
\end_inset

 ровно 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $1$
\end_inset

, 
\begin_inset Formula $3$
\end_inset

 и 
\begin_inset Formula $7$
\end_inset

 слогов соответственно.
 Все слова в языке племени - это непрерывные подстроки главной строки 
\begin_inset Formula $S$
\end_inset

.
 Длина 
\begin_inset Formula $S$
\end_inset

 составляет ровно 
\begin_inset Formula $n$
\end_inset

 символов и никогда не меняется.
 Однако, допустимы изменения самой строки 
\begin_inset Formula $S$
\end_inset

, что добавляет новые слова и запрещает старые.
 Надо придумать структуру данных для выполнения следующих операций: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
Поменять символ в строке 
\begin_inset Formula $S$
\end_inset

 на позиции 
\begin_inset Formula $i$
\end_inset

 на новый символ 
\begin_inset Formula $x$
\end_inset

 
\end_layout

\begin_layout Enumerate

\lang russian
Посчитать количество слогов в слове, которое является 
\begin_inset Formula $(l,r)$
\end_inset

-подстрокой строки 
\begin_inset Formula $S$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
Дан массив 
\begin_inset Formula $a$
\end_inset

 длины 
\begin_inset Formula $n$
\end_inset

, все числа целые неотрицательные и не превосходят 
\begin_inset Formula $C$
\end_inset

.
 Необходимо обработать онлайн 
\begin_inset Formula $q$
\end_inset

 запросов, каждый из которых бывает трёх типов:
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
Изменить какое-то 
\begin_inset Formula $a_{i}$
\end_inset

 
\end_layout

\begin_layout Enumerate

\lang russian
Все числа на отрезке 
\begin_inset Formula $[l_{i};r_{i}]$
\end_inset

 взять по модулю 
\begin_inset Formula $x_{i}$
\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
Найти сумму на отрезке 
\begin_inset Formula $[l_{i};r_{i}]$
\end_inset

 
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
Дан массив 
\begin_inset Formula $inv$
\end_inset

, где 
\begin_inset Formula $inv[i]$
\end_inset

 - это количество инверсий, которые образует 
\begin_inset Formula $i$
\end_inset

-ый элемент с элементами, которые левее его.
 Хотим по массиву 
\begin_inset Formula $inv$
\end_inset

 восстановить исходную перестановку.
 
\end_layout

\begin_layout Enumerate

\lang russian
Есть бесконечная последовательность, состоящая из всех положительных целых
 чисел в порядке возрастания: 
\begin_inset Formula $p={1,2,3,\ldots}$
\end_inset

.
 
\begin_inset Newline newline
\end_inset

К ней последовательно применили 
\begin_inset Formula $n$
\end_inset

 операций 
\begin_inset Formula $swap$
\end_inset

.
 Операция 
\begin_inset Formula $swap(a,b)$
\end_inset

 меняет местами элементы последовательности на позициях 
\begin_inset Formula $a$
\end_inset

 и 
\begin_inset Formula $b$
\end_inset

.
 Требуется найти количество инверсий после каждой операции 
\begin_inset Formula $swap$
\end_inset

, т.е.
 количество таких пар индексов 
\begin_inset Formula $(i,j)$
\end_inset

, что 
\begin_inset Formula $i<j$
\end_inset

 и 
\begin_inset Formula $p_{i}>p_{j}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\lang russian
Вам даны две перестановки 
\begin_inset Formula $p$
\end_inset

 и 
\begin_inset Formula $q$
\end_inset

 , состоящие из 
\begin_inset Formula $n$
\end_inset

 элементов, и 
\begin_inset Formula $m$
\end_inset

 запросов вида: 
\begin_inset Formula $l_{1},r_{1},l_{2},r_{2}$
\end_inset

 
\begin_inset Formula $(l_{1}\leq r_{1};l_{2}\leq r_{2})$
\end_inset

.
 
\begin_inset Newline newline
\end_inset

Ответом на запрос является количество целых чисел от 
\begin_inset Formula $1$
\end_inset

 до 
\begin_inset Formula $n$
\end_inset

, таких что их позиция в первой перестановке находится в отрезке 
\begin_inset Formula $[l_{1},r_{1}]$
\end_inset

 (границы отрезка включаются), а позиция во второй перестановке — в отрезке
 
\begin_inset Formula $[l_{2},r_{2}]$
\end_inset

 (границы отрезка включаются).
\begin_inset Newline newline
\end_inset

Позицией числа 
\begin_inset Formula $v$
\end_inset

 
\begin_inset Formula $(1\leq v\leq n)$
\end_inset

 в перестановке 
\begin_inset Formula $g_{1},g_{2},\ldots,g_{n}$
\end_inset

 называется такое число 
\begin_inset Formula $i$
\end_inset

 , что 
\begin_inset Formula $g_{i}=v$
\end_inset

 .
\end_layout

\begin_layout Enumerate

\lang russian
Вам дан ациклический связный граф.
 Необходимо ответить на 
\begin_inset Formula $q$
\end_inset

 запросов: найти 
\begin_inset Formula $LCA$
\end_inset

 для вершин 
\begin_inset Formula $v$
\end_inset

 и 
\begin_inset Formula $u$
\end_inset

.
\end_layout

\begin_layout Enumerate

\lang russian
Есть строка из 
\begin_inset Formula $n$
\end_inset

 круглых скобок.
 Нужно обрабатывать запросы: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
изменить 
\begin_inset Formula $i$
\end_inset

-ю скобку 
\end_layout

\begin_layout Enumerate

\lang russian
проверить, правильная ли сейчас последовательность
\end_layout

\begin_layout Enumerate

\lang russian
проверить, является ли правильной скобочной последовательностью подстрока
 с 
\begin_inset Formula $l$
\end_inset

 до 
\begin_inset Formula $r$
\end_inset

 
\end_layout

\begin_layout Enumerate

\lang russian
найти наибольший префикс подстроки с 
\begin_inset Formula $l$
\end_inset

 до 
\begin_inset Formula $r$
\end_inset

, который является правильной последовательностью
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
В решении этой задачи необходимо использовать Дерево отрезков 
\bar under
\color red
без интервальной модификации
\bar default
\color inherit
.
 
\begin_inset Newline newline
\end_inset

Опишите алгоритм решения следующей задачи.
 Перед вами полоска длины 
\begin_inset Formula $N$
\end_inset

 , разбитая на 
\begin_inset Formula $N$
\end_inset

 одинаковых квадратиков, пронумерованных слева направо числами от 
\begin_inset Formula $0$
\end_inset

 до 
\begin_inset Formula $N−1\text{.}$
\end_inset

 За одну операцию изменения (метод, предоставляемый интерфейсом вашей структуры
 данных) вы должны перекрасить все клетки с номерами от 
\begin_inset Formula $L$
\end_inset

 до 
\begin_inset Formula $R$
\end_inset

 включительно: белые должны стать черными, а черные - белыми.
 В запросах поиска необходимо определить цвет клетки в позиции 
\begin_inset Formula $X$
\end_inset

 .
 Изначально задается раскраска полоски в черный и белый цвет.
 
\begin_inset Newline newline
\end_inset

Интерфейс: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
Init(vector colors); Время работы метода должно быть линейным
\end_layout

\begin_layout Enumerate

\lang russian
ChangeColor(L, R); Время работы метода должно быть 
\begin_inset Formula $O(logN)$
\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
GetColor(X).
 Время работы метода должно быть 
\begin_inset Formula $O(logN)$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
Дано множество из 
\begin_inset Formula $n$
\end_inset

 точек в трехмерном пространстве с вещественными координатами 
\begin_inset Formula $(x_{i},\,y_{i},\,z_{i})$
\end_inset

.
 Точка 
\begin_inset Formula $(x_{i},\,y_{i},\,z_{i})$
\end_inset

 называется оптимальной по Парето, если 
\color red
не существует
\color inherit
 никакой другой точки 
\begin_inset Formula $(x_{j},\,y_{j},\,z_{j})$
\end_inset

 в множестве, такой, что 
\begin_inset Formula $x_{i}\leq x_{j},\,y_{i}\leq y_{j},\,z_{i}\leq z_{j}$
\end_inset

, причем хотя бы одно из неравенств строгое.
 Найти количество точек, оптимальных по Парето в данном множестве.
\end_layout

\begin_layout Enumerate

\lang russian
Дан массив из 
\begin_inset Formula $n$
\end_inset

 нулей.
 Предложите структуру, которая умеет реализовывать следующие операции:
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
Установить все значения от 
\begin_inset Formula $l$
\end_inset

 до 
\begin_inset Formula $r$
\end_inset

 в единицу
\end_layout

\begin_layout Enumerate

\lang russian
Установить все значения от 
\begin_inset Formula $l$
\end_inset

 до 
\begin_inset Formula $r$
\end_inset

 в ноль
\end_layout

\begin_layout Enumerate

\lang russian
Посчитать количество максимальных по включению отрезков, состоящих из единиц,
 внутри 
\begin_inset Formula $(l,\,r)$
\end_inset

-подмассива рассматриваемого массива 
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
На экране расположены прямоугольные окна, каким-то образом перекрывающиеся
 (со сторонами, параллельными осям координат).
 Вам необходимо найти точку, которая покрыта наибольшим числом из них.
 Окна заданы координатами левой нижней и правой верхней точки.
\end_layout

\begin_layout Enumerate

\lang russian
В граф добавляются и удаляются ребра.
 Требуется после каждого изменения печатать количество компонент связности.
\end_layout

\begin_layout Enumerate

\lang russian
Дано подвешенное дерево с корнем в первой вершине.
 Все ребра имеют веса (стоимости).
 Вам нужно ответить на 
\begin_inset Formula $M$
\end_inset

 запросов вида “найти у двух вершин минимум среди стоимостей ребер пути
 между ними”.
\end_layout

\begin_layout Part*

\size normal
\lang russian
Meet in the middle
\end_layout

\begin_layout Enumerate

\lang russian
Предложите алгоритм, который по заданному числу 
\begin_inset Formula $N$
\end_inset

 находит количество четверок целых положительных чисел 
\begin_inset Formula $(x,y,z,t)$
\end_inset

 - решений уравнения:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
x^{2}+y^{2}+z^{2}+t^{2}=N
\]

\end_inset


\end_layout

\begin_layout Enumerate

\lang russian
У вас есть несколько камней известного веса 
\begin_inset Formula $w_{1},\,w_{2},\,\ldots w_{n}$
\end_inset

.
 Придумайте, как распределить камни в две кучи так, что разность весов этих
 двух куч будет минимальной.
\end_layout

\begin_layout Enumerate

\lang russian
Задано прямоугольное поле размера 
\begin_inset Formula $n\times m$
\end_inset

.
 В каждой клетке записано целое число; число, записанное в клетке 
\begin_inset Formula $(i,j)$
\end_inset

 равно 
\begin_inset Formula $a_{ij}$
\end_inset

.
 
\begin_inset Newline newline
\end_inset

Ваша задача — посчитать количество путей из клетки 
\begin_inset Formula $(1,1)$
\end_inset

 в клетку 
\begin_inset Formula $(n,m)$
\end_inset

, удовлетворяющих следующим условиям: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
Из клетки можно перемещаться только вниз или только вправо.
 Более формально, из клетки 
\begin_inset Formula $(i,j)$
\end_inset

 можно переместиться в клетку 
\begin_inset Formula $(i,j+1)$
\end_inset

 или в клетку 
\begin_inset Formula $(i+1,j)$
\end_inset

.
 
\end_layout

\begin_layout Enumerate

\lang russian
\begin_inset Formula $Xor$
\end_inset

 всех чисел на пути из клетки 
\begin_inset Formula $(1,1)$
\end_inset

 в клетку 
\begin_inset Formula $(n,m)$
\end_inset

 должен быть равен 
\begin_inset Formula $k$
\end_inset

.
 
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
Даны 
\begin_inset Formula $a,b,m$
\end_inset

.
 Хотим найти решение уравнения: 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
a^{x}=b\mod m
\]

\end_inset


\begin_inset Newline newline
\end_inset

где 
\begin_inset Formula $a$
\end_inset

 и 
\begin_inset Formula $m$
\end_inset

 взаимно просты.
\end_layout

\begin_layout Enumerate

\lang russian
Дан неориентированный, невзвешенный граф 
\begin_inset Formula $G$
\end_inset

.
 Нужно найти количество подклик данного графа.
 Граф задан матрицей смежности.
\end_layout

\begin_layout Part*

\size normal
\lang russian
Разное
\end_layout

\begin_layout Enumerate

\lang russian
У нас есть число 
\begin_inset Formula $1$
\end_inset

, за ход можно заменить его на любое из 
\begin_inset Formula $x+1$
\end_inset

, 
\begin_inset Formula $x+5$
\end_inset

, 
\begin_inset Formula $2x$
\end_inset

, 
\begin_inset Formula $5x$
\end_inset

.
 За какое минимальное число ходов мы можем получить 
\begin_inset Formula $n$
\end_inset

?
\end_layout

\begin_layout Enumerate

\lang russian
Даны две последовательности 
\begin_inset Formula $a$
\end_inset

 и 
\begin_inset Formula $b$
\end_inset

, найти 
\begin_inset Formula $c$
\end_inset

, являющуюся подпоследовательностью и 
\begin_inset Formula $a$
\end_inset

, и 
\begin_inset Formula $b$
\end_inset

 такую, что 
\begin_inset Formula $len(c)\rightarrow\max$
\end_inset

.
\begin_inset Newline newline
\end_inset

Например, для последовательностей
\begin_inset Formula $\langle1,3,10,2,7\rangle$
\end_inset

 и 
\begin_inset Formula $\langle3,5,1,2,7,11,12\rangle$
\end_inset

 возможными ответами являются 
\begin_inset Formula $\langle3,2,7\rangle$
\end_inset

 и 
\begin_inset Formula $\langle1,2,7\rangle$
\end_inset

.
\end_layout

\begin_layout Enumerate

\lang russian
Дан склад грузов 
\begin_inset Formula $a_{1},\,a_{2},\,\ldots,a_{n}$
\end_inset

.
 Есть бесконечное множество машин размера 
\begin_inset Formula $K$
\end_inset

.
 При погрузке должно выполняться требование, что 
\begin_inset Formula $\sum a_{i}\leq K$
\end_inset

.
 Загружают машины по одной, погруженная машина сразу уезжает.
 Погрузчик может брать только самый левый/правый груз из массива.
 
\begin_inset Newline newline
\end_inset

Задача: минимизировать число машин, использованное для перевозки грузов.
\end_layout

\begin_layout Enumerate

\lang russian
Нам дано 
\begin_inset Formula $n$
\end_inset

 предметов с натуральными весами 
\begin_inset Formula $a_{0},a_{1},\ldots,a_{n-1}$
\end_inset

.
 Требуется выбрать подмножество предметов суммарного веса не больше 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Enumerate

\lang russian
Дана последовательность 
\begin_inset Formula $a$
\end_inset

 длины 
\begin_inset Formula $n$
\end_inset

.
 Найти ее самую длинную возрастающую подпоследовательность.
\end_layout

\begin_layout Enumerate

\lang russian
Найти количество способов закрасить таблицу 
\begin_inset Formula $n\times m$
\end_inset

 с помощью 
\begin_inset Formula $0$
\end_inset

 и 
\begin_inset Formula $1$
\end_inset

 так, чтобы не было квадратов 
\begin_inset Formula $2\times2$
\end_inset

 только из 
\begin_inset Formula $0$
\end_inset

 или 
\begin_inset Formula $1$
\end_inset

.
 
\end_layout

\begin_layout Part*

\size normal
\lang russian
Декомпозиция
\end_layout

\begin_layout Enumerate

\lang russian
У вас есть поезд, в котором 
\begin_inset Formula $k$
\end_inset

 мест.
 Поезд идет через 
\begin_inset Formula $N+1$
\end_inset

 город (занумерованы от 
\begin_inset Formula $0$
\end_inset

 до 
\begin_inset Formula $N$
\end_inset

).
 Когда человек хочет купить билет, он называет два числа 
\begin_inset Formula $x$
\end_inset

 и 
\begin_inset Formula $y$
\end_inset

 — номера станций, откуда и куда он хочет ехать.
 При наличии хотя бы одного сидячего места на этом участке на момент покупки
 ему продается билет, иначе выдается сообщение «билетов нет» и билет не
 продается.
 Ваша задача — написать программу, обслуживающую такого рода запросы в порядке
 их прихода.
\end_layout

\begin_layout Enumerate

\lang russian
Надо придумать способ, как можно достаточно эффективно отвечать на следующие
 запросы: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
найти сумму на отрезке 
\end_layout

\begin_layout Enumerate

\lang russian
вставить новый элемент на позицию 
\begin_inset Formula $i$
\end_inset

 
\end_layout

\begin_layout Enumerate

\lang russian
удалить 
\begin_inset Formula $i$
\end_inset

-ый элемент
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
Научиться отвечать на следующие запросы: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
Увеличить все элементы на отрезке на 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Enumerate

\lang russian
Найти количество элементов, которые 
\begin_inset Formula $\leq x$
\end_inset

 на отрезке от 
\begin_inset Formula $l$
\end_inset

 до 
\begin_inset Formula $r$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
Дано 
\begin_inset Formula $k$
\end_inset

 бочонков с медом 
\begin_inset Formula $kegs$
\end_inset

, стоящие в ряд.
 
\begin_inset Newline newline
\end_inset

У каждого бочонка есть значение 
\begin_inset Formula $s_{i}$
\end_inset

–текущие количество меда в нем, 
\begin_inset Formula $c_{i}$
\end_inset

 - объем бочонка.
\begin_inset Newline newline
\end_inset

Есть операция прибавить на отрезке с 
\begin_inset Formula $l$
\end_inset

 по 
\begin_inset Formula $r$
\end_inset

 арифметическую прогрессию:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
kegs_{l}+a,kegs_{l+1}+a+b,kegs_{l+2}+a+2b,\ldots,kegs_{r-1}+a+(r-1-l)\cdot b
\]

\end_inset


\begin_inset Newline newline
\end_inset

Необходимо для каждого бочонка вывести первый запрос, когда он переполнится.
\end_layout

\begin_layout Enumerate

\lang russian
Дан граф.
 Два вида запросов: 
\end_layout

\begin_deeper
\begin_layout Enumerate

\lang russian
перекрасить вершину в какой-то цвет 
\end_layout

\begin_layout Enumerate

\lang russian
сказать сколько для данной вершины различных цветов среди ее соседей
\end_layout

\end_deeper
\begin_layout Enumerate

\lang russian
Маленький Петя очень любит играть.
 Больше всего он любит играть в игру «Лунки».
 Это игра для одного игрока со следующими правилами: 
\begin_inset Newline newline
\end_inset

Есть 
\begin_inset Formula $N$
\end_inset

 лунок, расположенных в ряд, пронумерованных слева направо числами от 
\begin_inset Formula $1$
\end_inset

 до 
\begin_inset Formula $N$
\end_inset

.
 У каждой лунки изначально установлена своя сила выброса (у лунки с номером
 
\begin_inset Formula $i$
\end_inset

 она равна 
\begin_inset Formula $a_{i}$
\end_inset

).
 Если вбросить шарик в лунку 
\begin_inset Formula $i$
\end_inset

, то он тут же вылетит из нее и попадет в лунку 
\begin_inset Formula $i+a_{i}$
\end_inset

, после чего он опять вылетит и т.д..
 Если же лунки с таким номером нету, то он просто вылетит за край ряда.
 
\begin_inset Newline newline
\end_inset

Вам необходимо научиться обрабатывать 
\begin_inset Formula $M$
\end_inset

 ходов, каждый из которых может иметь следующий вид:
\end_layout

\begin_deeper
\begin_layout Itemize

\lang russian
Установить силу выброса лунки 
\begin_inset Formula $a$
\end_inset

 равной 
\begin_inset Formula $b$
\end_inset

.
\end_layout

\begin_layout Itemize

\lang russian
Вбросить шарик в лунку 
\begin_inset Formula $a$
\end_inset

 и посчитать количество прыжков шарика, прежде чем он вылетит за край ряда,
 а так же записать номер лунки, после выпрыгивания из которой шарик вылетел
 за край.
\end_layout

\end_deeper
\begin_layout Part*

\size normal
\lang russian
Персистентные структуры
\end_layout

\begin_layout Enumerate

\lang russian
Дано 
\begin_inset Formula $n$
\end_inset

 целых чисел 
\begin_inset Formula $a_{1},\,a_{2},\ldots,a_{n}$
\end_inset

 и 
\begin_inset Formula $q$
\end_inset

 запросов.
 Запрос — числа 
\begin_inset Formula $l$
\end_inset

 и 
\begin_inset Formula $k$
\end_inset

.
 Ответ на запрос — минимальное число 
\begin_inset Formula $r$
\end_inset

, такое что 
\begin_inset Formula $a[l\ldots r]$
\end_inset

 содержит 
\begin_inset Formula $k$
\end_inset

 различных чисел.
\end_layout

\begin_layout Enumerate

\lang russian
Как можно реализовать персистентный двусвязный список? Определить тип персистент
ности.
 Посчитать амортизированную оценку для операции 
\begin_inset Formula $insert$
\end_inset

.
 
\end_layout

\begin_layout Enumerate

\lang russian
Как можно реализовать персистентный статический массив? Определить тип персистен
тности.
\end_layout

\begin_layout Enumerate

\lang russian
Как можно применить персистентное до для решения задачи про мед.
\end_layout

\begin_layout Enumerate

\lang russian
Как можно применить персистентное до для решения задачи про две перестановки.
\end_layout

\end_body
\end_document
