%% LyX 2.3.6.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[russian,english]{article}
\usepackage[T2A,T1]{fontenc}
\usepackage[koi8-r,latin9]{inputenc}
\usepackage{geometry}
\geometry{verbose,tmargin=1cm,bmargin=2cm,lmargin=1cm,rmargin=1cm}
\usepackage{xcolor}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxcode}
	{\par\begin{list}{}{
		\setlength{\rightmargin}{\leftmargin}
		\setlength{\listparindent}{0pt}% needed for AMS classes
		\raggedright
		\setlength{\itemsep}{0pt}
		\setlength{\parsep}{0pt}
		\normalfont\ttfamily}%
	 \item[]}
	{\end{list}}

\makeatother

\begin{document}
\selectlanguage{russian}%
\inputencoding{koi8-r}%

\part*{{\normalsize{}Трудоемкость в худшем случае}}

\textcolor{red}{Вспомнить про $O(n),\,\Theta(n),\,\Omega(n)$ + сделать
небольшой тест (?).}

Порекомендовать почитать Кормена (глава 3).

\subsection*{{\normalsize{}$\Theta:$}}

\[
\Theta(g(n))=\begin{cases}
f(n) & if\,\exists c_{1},\,c_{2},\,n_{0}:\,0\leq c_{1}\cdot g(n)\leq f(n)\leq c_{2}\cdot g(n)\,\forall n\geq n_{0}\end{cases}
\]

Поскольку $\Theta(g(n))$ представляет собой множество функций, то
можно записать $f(n)\in\Theta(g(n))$ или $f(n)=\Theta(g(n))$. 

Говорят, что функция $g(n)$ является асимптотически точной оценкой
функции $f(n).$

\subsection*{{\normalsize{}$O:$}}

\[
O(g(n))=\begin{cases}
f(n) & if\,\exists c,\,n_{0}:\,0\leq f(n)\leq c\cdot g(n)\,\forall n\geq n_{0}\end{cases}
\]

$O$-обозначение применяется, когда надо указать верхнюю границу функции
с точностью до постоянного множителя.

\subsection*{{\normalsize{}$\Omega:$ }}

\[
\Omega(g(n))=\begin{cases}
f(n) & if\,\exists c,\,n_{0}:\,0\leq c\cdot g(n)\leq f(n)\,\forall n\geq n_{0}\end{cases}
\]

$\Omega$ - это асимптотическая нижняя граница.

${}$

\includegraphics[scale=0.4]{img/1}

\part*{{\normalsize{}Амортизационный анализ}}

\textcolor{red}{\uuline{Вопрос}}: зачем вообще он нужен и что это
такое?

Амортизационный анализ (amortized analysis) -- метод анализа алгоритмов,
позволяющий осуществлять оценку времени выполнения последовательности
из $n$ операций над некоторой структурой данных. При выполнении амортизационного
анализа гарантируется \textcolor{red}{\uline{средняя производительность
в наихудшем случае.}}

Некоторые операции структуры данных могут иметь высокую вычислительную
сложность, другие низкую. Например, некоторая операция может подготавливать
структуру данных для быстрого выполнения других операций. Такие \guillemotleft тяжелые\guillemotright{}
операции выполняются редко и могут оказывать незначительное влияние
на суммарное время выполнения последовательности из $n$ операций.

Введен в практику Робертом Тарьяном ( Robert Tarjan ) в 1985 году.

\paragraph*{Вспомнить про вектор (задача, которую разбирали на паре) + предложить
придумать способ реализовать вектор с оценкой $O(1)$ в худшем случае
на добавление элемента в конец (если выделение памяти происходит за
константу).}

\section*{{\normalsize{}Метод усреднения (метод группового анализа или aggregate
analysis)}}

Метод усреднения - это метод амортизационного анализа, позволяющий
оценивать верхнюю границу времени $T(n)$ выполнения последовательности
из $n$ операций в худшем случае.

В методе усреднения амортизационная стоимость операций определяется
следующим образом: суммарная стоимость всех операций алгоритма делится
на их количество.

\[
a=\frac{\sum_{i=1}^{n}t_{i}}{n}
\]

где $t_{i}$- это время выполнения $i$-ой операции. 

Амортизированная стоимость операции -- это оценка сверху среднего
времени выполнения операции в худшем случае.

\subsection*{{\normalsize{}Задачи}}
\begin{enumerate}
\item стек с операцией multipop
\item двоичный счётчик
\item стек с multipop и multipush
\item счетчик с decrement
\item упражнение
\end{enumerate}

\paragraph*{Стек с multipop.}
\begin{lyxcode}
push(s,~x)~//~добавляем~объект~x~в~стек~s

pop(s)~//~``снимает''~вершину~стека~(ошибка~для~пустого~стека)

multipop(s,~k)~//~``снимает''~k~вершин~стека~
\end{lyxcode}
\textcolor{purple}{Спросить про стоимость операций push и pop. Написать
псевдокод операции.}
\begin{lyxcode}
def~multipop(s,~k):

~~~~while~empty(s)~==~False~and~k~>~0:

~~~~~~~~pop(s)

~~~~~~~~-{}-k
\end{lyxcode}
Количество итераций в цикле будет зависеть от реального количества
объектов в стеке и $k$ $\Rightarrow$ мы их сделаем $\min(size(s),k).$
На каждой итерации выполняется однократный вызов операции $pop$ $\Rightarrow$
полная стоимость выполнения операции $multipop$ будет равна $\min(size(s),k).$

Проанализируем последовательность операций $push,\,pop,\,multipop$,
действующие на изначально пустой стек. Пусть $n=size(s).$ Стоимость
операции $mulpipop$ в наихудшем случае равна $O(n),$так как в стеке
не более $n$ объектов. Покажем, что произвольная последовательность
операций $push,\,pop,\,multipop$ не превышает $O(n).$

Каждый помещенный в стек объект может быть извлечен оттуда не более
одного раза $\Rightarrow$ число вызовов операции $pop$ (включая
их вызовы в процедуре $multipop$) для непустого стека не превышает
количество произведенных операций $push$, которое, в свою очередь,
не больше $n$. При любом $n$ для выполнения произвольной последовательности
из $n$ операций $push,\,pop,\,multipop$ требуется суммарное время
$O(n)\,\Rightarrow$ средняя стоимость будет $\frac{O(n)}{n}=O(1)$.

Распишем приведённые рассуждения более формально. Пусть $m$ ---
количество операций, $n$ --- количество элементов, задействованных
в этих операциях. Очевидно, $n\leqslant m$.

Тогда:

\[
a=\frac{\sum_{i=1}^{m}t_{i}}{m}=\frac{\sum_{i=1}^{m}\sum_{j=1}^{n}t_{ij}}{m}=\frac{\sum_{j=1}^{n}\sum_{i=1}^{m}t_{ij}}{m}
\]

где $t_{ij}$ --- стоимость $i$-ой операции над $j$-ым элементом.
Величина $\sum_{i=1}^{m}t_{ij}\leq2$, так как над элементом можно
совершить только две операции, стоимость которых равна 1 (добавили
и удалили).

Тогда: $a\leq\frac{2n}{m}\leq[n\leq m]\leq2=>a=O(1).$

В групповом анализе амортизированная стоимость каждой операции принимается
равной ее средней стоимости, поэтому в этом случае все три стековые
операции будут характеризоваться одинаковой амортизированной стоимостью
$O(1).$

\paragraph*{Двоичный счётчик.}

В качестве счетчика будем использовать битовый массив $A[0\ldots k-1],$
где $A.length=k$. Младший бит хранящегося в счетчике бинарного числа
$x$ находится в элементе $A[0]$, старший - в элементе $A[k-1].$
$x=\sum_{i=0}^{k-1}A[i]\cdot2^{i}.$

Изначально $x=0\,\Rightarrow\,A[i]=0,\,i\,\in[0\ldots k-1].$ 
\begin{lyxcode}
~x~~7~6~5~4~3~2~1~0~|~стоимость

~

~0~~0~0~0~0~0~0~0~0~|~0

~1~~0~0~0~0~0~0~0~1~|~1

~2~~0~0~0~0~0~0~1~0~|~3

~3~~0~0~0~0~0~0~1~1~|~4

~4~~0~0~0~0~0~1~0~0~|~7

~5~~0~0~0~0~0~1~0~1~|~8

~6~~0~0~0~0~0~1~1~0~|~10

~7~~0~0~0~0~0~1~1~1~|~11

~8~~0~0~0~0~1~0~0~0~|~15

~9~~0~0~0~0~1~0~0~1~|~16

10~~0~0~0~0~1~0~1~0~|~18

11~~0~0~0~0~1~0~1~1~|~19

12~~0~0~0~0~1~1~0~0~|~22

13~~0~0~0~0~1~1~0~1~|~23

14~~0~0~0~0~1~1~1~0~|~25

15~~0~0~0~0~1~1~1~1~|~26

16~~0~0~0~1~0~0~0~0~|~31
\end{lyxcode}
\textcolor{purple}{Предложить реализовать процедуру увеличения счетчика
на 1.}

Чтобы увеличить показания счетчика на 1 используется следующая процедура
:
\begin{lyxcode}
def~Increment(A):

~~~~i~=~0

~~~~while~i~<~A.length~and~A{[}i{]}~==~1:

~~~~~~~~A{[}i{]}~=~0

~~~~~~~~i~+=~1

~~~~if~i~<~A.length

~~~~~~~~A{[}i{]}~=~1
\end{lyxcode}
Заметим, что значение всех бит изменяются не при каждом вызове $Increment.$ 

Посмотрим, как часто меняется $A[0],\,A[1]$ и т.д. Увидим, что в
общем случае для $i=0,\ldots,k-1$ бит $A[i]$ изменяется $\lfloor\frac{n}{2^{i}}\rfloor$
раз в последовательности из $n$ операций $Increment$ для изначально
обнуленного счетчика. Таким образом, общее количество изменений битов
при выполнении последовательных операций $Increment$ равно: 
\[
\sum_{i=0}^{k-1}\lfloor\frac{n}{2^{i}}\rfloor<n\sum_{i=0}^{k-1}\frac{1}{2^{i}}<n\sum_{i=0}^{\infty}\frac{1}{2^{i}}=2n
\]

Поэтому время выполнения последовательности из $n$ операций $Increment$
над изначально обнуленным счетчиком в наихудщем случае равно $O(n).$
Средняя стоимость операций равна $a=\frac{O(n)}{n}=O(1).$

\paragraph*{Стек с multipop и multipush.}

Остается ли справедливой амортизированная оценка стоимости стековых
операций, равная $O(1),$ если включить в множество стековых операций
операцию $multipush,$ помещающая в стек $k$ элементов? 

\paragraph{Счетчик с decrement (можно в anytask?). }

Покажите, что если бы в примере с $k-$битовым счетчиком была включена
операция $decrement,$то стоимость операций была бы равна $\Theta(kn)$.

\paragraph*{Упражнение (можно в anytask?). }

Предположим, что над структурой данных выполняется $n$ операций.
Стоимость $i-$ой по порядку операции равна $i$, если $i$ - это
точная степень двойки, и 1 - иначе. Определить с помощью группового
анализа, метода предоплаты и метода потенциалов амортизированную стоимость
операции.

\section*{{\normalsize{}Метод предоплаты (accounting method)}}

Разные операции будет оцениваться по-разному, в зависимости от их
фактической стоимости. 

Величина, которая ``начисляется'' на операцию называется амортизированной
стоимостью (amortized cost). Если амортизированная стоимость операции
превышает ее фактическую стоимость, то соответствующая разность присваивается
определенным объектам структуры данных как кредит. Кредит можно использовать
впоследствии для компенсирующих выплат на операции, амортизированная
стоимость которых меньше их фактической стоимости. Т.о., можно полагать,
что амортизированная стоимость операции состоит из ее фактической
стоимости и кредита, который либо накапливается, либо расходуется.

Пусть $c_{i}$- это фактическая стоимость $i-$ой операции, а $\widehat{c_{i}}-$
это ее же амортизированная стоимость. Тогда должно выполняться следующее
неравенство:

\begin{equation}
\sum_{i=1}^{n}\hat{c_{i}}\geq\sum_{i=1}^{n}c_{i}\label{eq:1}
\end{equation}

Общий кредит, хранящийся в структуре данных вычисляется следующим
образом: $credit=\sum_{i=1}^{n}\hat{c_{i}}-\sum_{i=1}^{n}c_{i}$.
Так как у нас есть неравенство \ref{eq:1}, то получаем, что $credit\geq0$.
Если бы полный кредит в каком-то случае мог стать отрицательным, то
полная амортизированная стоимость было бы в этот момент ниже соответствующей
фактической стоимости.

\subsection*{{\normalsize{}Задачи}}
\begin{enumerate}
\item стек с операцией multipop
\item двоичный счетчик
\item рекурсивный обход дерева
\item стек с копированием
\item счетчик с reset
\end{enumerate}

\paragraph*{Stack (multipop). }

Фактическая стоимость операция у нас следующая:
\begin{lyxcode}
push~~~~~~1

pop~~~~~~~1

multipop~~min(n,~k)
\end{lyxcode}
Приведем ниже амортизированные стоимости:
\begin{lyxcode}
push~~~~~~2

pop~~~~~~~0

multipop~~0
\end{lyxcode}
Заметим, что амортизированная стоимость операции $multipop$ у нас
равна константе, в то время как ее фактическая стоимость - это переменная
величина. 

В этой схеме все три амортизированные стоимости равны $O(1),$ хотя
в общем случае асимптотическое поведение амортизированных стоимостей
рассматриваемых операций может быть разным. 

Осталось доказать, что любую последовательность операций можно ``оплатить''
путем начисления амортизированных стоимостей. \textcolor{purple}{(Предложить
порассуждать самим).}

\paragraph*{Двоичный счётчик.}

Начислим на операцию, при которой биту присваивается значение, амортизированную
стоимость, равную двум. Когда бит устанавливается, единица расходуется
на саму операцию + получаем еще единицу в кредит для последующего
использования (для обнуления). В любой момент времени с каждой единицей
в счетчике связана единица в кредит $\Rightarrow$ на обнуление бита
нет необходимости начислять что-то. 

Определим амортизационную стоимость операции $Increment$. Стоимость
обнуления битов выплачивается из кредита, который мы получили от единичных
битов. В процедуре $Increment$ в 1 устанавливается не более одного
бита, поэтому амортизационная стоимость операции $Increment$ не превышает
2. Кредит не может быть отрицательным $\Rightarrow$ условие \ref{eq:1}
выполняется. Амортизационная стоимость $n$ операций $Increment$
равна $O(n).$

\paragraph*{Рекурсивный обход дерева.}

\paragraph*{Стек с копированием.}

Предположим, что над стеком выполняется последовательность операций.
Размер стека при этом никогда не превышает $k$. После каждых $k$
операций производится резервное копирование стека. Присвоив различным
стековым операциям соответствующие стоимости, покажите, что стоимость
$n$ стековых операций, включая копирование стека, равна $O(n).$

\paragraph*{Счетчик с reset.}

Предположим, что нам нужно иметь возможность не только увеличивать
показания счетчика, но и сбрасывать его. Считая, что время проверки
или модификации одного бита составляют $\Theta(1),$ покажите, как
осуществить реализацию счетчика в виде массива битов, чтобы выполнение
произвольной последовательности из $n$ операций $Increment$ и $Reset$
над изначально обнуленным счетчиком потребовало бы время $O(n).$

\section*{{\normalsize{}Метод потенциалов}}

Если в методе предоплаты мы использовали кредиты, то в методе потенциалов
вводится понятие ``потенциальной энергии'' или ``потенциала'',
который можно высвободить для оплаты следующих операций. Этот потенциал
связан со структурой в целом, а не с ее отдельными объектами. 

Мы начинаем с исходной структуры данных $D_{0}$, над которой выполняется
$n$ операций. Для всех $i=1,2,\ldots,n$ обозначим через $c_{i}$
фактическую стоимость $i$-ой операции, а через $D_{i}$ - структуру
данных, которая получается в результате применения $i-$ой операции
к структуре $D_{i-1}.$ Функция потенциала $\Phi$ отображает каждую
структуру данных $D_{i}$ на действительно число $\Phi(D_{i}),$ которое
является потенциалом, связанным с структурой $D_{i}.$ Амортизированная
стоимость $\hat{c_{i}}$ $i$-ой операции определяется соотношением: 

\begin{equation}
\hat{c_{i}}=c_{i}+\Phi(D_{i})-\Phi(D_{i-1})\label{eq: 2}
\end{equation}

Полная амортизированная стоимость после выполнения $n$ операций будет
равна:

\begin{equation}
\sum_{i=1}^{n}\hat{c_{i}}=\sum_{i=1}^{n}(c_{i}+\Phi(D_{i})-\Phi(D_{i-1}))=\sum_{i=1}^{n}c_{i}+\Phi(D_{n})-\Phi(D_{0})\label{eq:3}
\end{equation}

\begin{equation}
\Phi(D_{n})\geq\Phi(D_{0})\label{eq:4}
\end{equation}

Если функцию потенциала определить таким образом, чтобы выполнялось
неравенство \ref{eq:4}, то полная амортизированная стоимость $\sum_{i=1}^{n}\hat{c_{i}}$
является верхней границей полной фактической стоимости $\sum_{i=1}^{n}c_{i}.$

\textcolor{red}{Вопрос:} а почему нам важно, чтобы выполнялось \ref{eq:4}?

Так как на практике не всегда известно, сколько операций будет выполнено,
то иногда накладывают дополнительные ограничения: $\Phi(D_{i})\geq\Phi(D_{0})$.
Часто удобно определить $\Phi(D_{0})=0,$ а зачем показать, что значение
потенциала для всех $i$ неотрицательное. 

\subsection*{{\normalsize{}Задачи}}
\begin{enumerate}
\item стек с операцией multipop
\item двоичный счетчик
\end{enumerate}

\paragraph*{Stack (multipop).}

$\Phi(D_{0})=0,\,\Phi(D_{i})=n$

Так как количество объектов в стеке не может быть отрицательным, стеку
$D_{i}$, полученному после выполнения $i-$ой операции, соответствует
неотрицательный потенциал.

Вычислим амортизированные стоимости различных стековых операций.

Для $Push$:

\[
\Phi(D_{i})-\Phi(D_{i-1})=(n+1)-n=1
\]

Вспомним формулу \ref{eq: 2}. Тогда амортизированная оценка для операции
$push$ будет следующей:

\[
\hat{c_{i}}=c_{i}+\Phi(D_{i})-\Phi(D_{i-1})=1+1=2
\]

Предположим, что $i-$ая операция над стеком - это $multipop(s,k)$.
$k'=\min(k,n)$. $c_{i}=k',\,\Phi(D_{i})-\Phi(D_{i-1})=-k'.\,\hat{c_{i}}=k'-k'=0.$
Аналогично для $pop$. 

Получили, что амортизированная стоимость каждой операции равна $O(1)$
+ амортизированная стоимость $n$ операций равна $O(n)$ + выполняются
все ограничения на значения потенциалов. 

\textcolor{red}{\uuline{Вопрос:}}\textcolor{red}{{} }\textcolor{black}{чему
равна полная стоимость выполнения $n$ стековых операций $push,\,pop,\,multipop$,
если предположить, что в начале стек содержит $k$ объектов, а в конце
$m.$}

\paragraph*{Двоичный счетчик.}

$k$ - количество бит в счетчике. 

Потенциал счетчика после выполнения $i-$ой операции $Increment$
определим как количество $b_{i},$содержащихся в счетчике единиц после
этой операции.

Пусть $i-$ая операция $Increment$ обнулит $t_{i}$ бит. В таком
случае фактическая стоимость этой операции не превышает $c_{i}\leq t_{i}+1$. 

Если $b_{i}=0,$ то входе выполнения $i-$ой операции все $k$ бит,
так что $b_{i-1}=t_{i}=k.$ 

Если $b_{i}>0$, то выполняется соотношение $b_{i}\leq b_{i-1}-t_{i}+1$.

\[
\Phi(D_{i})-\Phi(D_{i-1})\leq(b_{i-1}-t_{i}+1)-b_{i-1}=1-t_{i}
\]

\[
\hat{c_{i}}=c_{i}+\Phi(D_{i})-\Phi(D_{i-1})\leq t_{i}+1+1-t_{i}=2
\]

Если вначале показание счетчика равно $0$, то $\Phi(D_{0})=0.$ $\Phi(D_{i})\geq0.$ 

Метод потенциалов предоставляет способ анализа счетчика даже для того
случая, когда начальное значение счетчика не равно нулю. 

Пусть изначально счетчик содержит $b_{0}$ единиц, а после выполнения
$n$ операций $Increment$ - $b_{n}$. $0\leq b_{0},b_{n}\leq k.$

Тогда уравнение \ref{eq:3} можно переписать следующим образом:

\[
\sum_{i=1}^{n}c_{i}=\sum_{i=1}^{n}\hat{c_{i}}-\Phi(D_{n})+\Phi(D_{0})
\]

Для всех $1\leq i\leq n$ выполняется неравенство $\hat{c_{i}}\leq2$
(получили выше). $\Phi(D_{0})=b_{0},\,\Phi(D_{n})=b_{n}$. Получим:

\[
\sum_{i=1}^{n}c_{i}\leq\sum_{i=1}^{n}2-b_{n}+b_{0}=2n+b_{n}-b_{0}
\]

Так как $0\leq b_{0},b_{n}\leq k$, то при $k=O(n)$ полная фактическая
стоимость равна $O(n)$. Другими словами, если выполняется не менее
$n=\Omega(k)$ операций $Increment$, то полная фактическая стоимость
независимо от начального показания счетчика равна $O(n).$

\pagebreak{}

\section*{{\normalsize{}Стек, очередь, дек с поиском минимального элемента }}

Необходимо добавить операцию поиска минимального элемента в классический
интерфейс.

\subsection*{{\normalsize{}Стек}}

Хотим добавить операции $min(s)$, которая будет возвращать минимальный
элемент для стека $s$ за время $O(1)$ + сохранить оценки на $push$
и $pop.$

Решение: хранить пары $(current\_value,\,current\_min).$

\subsection*{{\normalsize{}Очередь}}

Просто очередь на стеках на минимум.

Решение: заведем два стека на минимум $s_{1}$ и $s_{2}\text{.}$
Добавлять новые элементы будет всегда в стек $s_{1}$, а извлекать
элементы - только из стека $s_{2}$. При этом, если при попытке извлечения
элемента из стека $s_{2}$ он оказался пустым, просто перенесём все
элементы из стека $s_{1}$ в стек $s_{2}$ (при этом элементы в стеке
$s_{2}$ получатся уже в обратном порядке, что нам и нужно для извлечения
элементов; стек $s_{1}$ же станет пустым). Наконец, нахождение минимума
в очереди будет фактически заключаться в нахождении минимума из минимума
в стеке $s_{1}$ и минимума в стеке $s_{2}$.

Тем самым, мы выполняем все операции по-прежнему за $O(1)$ (по той
простой причине, что каждый элемент в худшем случае 1 раз добавляется
в стек $s_{1}$, 1 раз переносится в стек $s_{2}$ и 1 раз извлекается
из стека $s_{2}$).

\subsection*{{\normalsize{}Дек}}

\textcolor{purple}{Сказать подумать. Спросить на второй практике}
\begin{lyxcode}
empty~~~~~//~проверка~на~наличие~элементов

pushBack~~//~операция~вставки~нового~элемента~в~конец

popBack~~//~операция~удаления~конечного~элемента

pushFront~//~операция~вставки~нового~элемента~в~начало

popFront~~//~операция~удаления~начального~элемента
\end{lyxcode}

\subsubsection*{Добавить один много раз}

Имеется двоичный счетчик из $k$ бит в начальном состоянии $b_{1}b_{2}\ldots b_{k}$.
Выполним операцию инкремента $n$ раз. Определите наибольшее число
изменившихся бит за одну операции инкремента и среднее число изменившихся
битов.

Заметим, что если $i+1$ бит равен $1$, то каждое нечетное его изменение
повлечет изменение $i$-ого бита, если $0$ - то каждое четное.\selectlanguage{english}%

\end{document}
